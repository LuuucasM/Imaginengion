- add sound
	- likely to use mini audio
	- likely need to create an audio manager abstraction even tho mini audio is multi platform, just like i do with opengl even though its multiplatform
	- thats about all i know right now lol because i dont really know much about audio in general but i guess im about to learn :)
- change core of the engine to a mediator pattern mentioned in this video https://www.youtube.com/watch?v=Sa1Z4GlY7As
	- mediator pattern afaik looks to be similar to how allocators and io is done in zig. 
	- as we know from zig passing around a reference does not really impact performance so that is ok
	- the good thing is the entire engine like renderer, and everything can exist in one memory space, and we dont need to have global memory space used.
	- additionally we already sort of have the concept of this in the engine already but its used only for scripts and contains only a couple of things but i can just extend it to the whole engine and that will be good. this way it simplifies dependencies, consolidates memory, and 
- change asset manager
	- make it so that each asset type has a "default asset" that is stored in the asset manager
	- then when doing GetAsset it can actually never fail and instead we handle errors inside the asset manager
	- if we encounter any error we can instead return the "default asset" for that type
	- i will need to make a GetAssetHandleRef("default") or something like this because normally get asset handle ref takes in a path but for the default assets we can maybe just type default and then the asset labeled as default will have a component for every asset type which is the default asset of that specific type. then when we do GetAsset on a default handle we return one of those default assets
	- then now that we have default, when doing GetAssetHandleRef for actual paths given, if we encounter any error we can instead return the asset for that type using the default handle instead and then of course print the error that was generated
	- i have to ensure that the initialization of default is done successfully and asserted because it is a core part of the engine that needs to exist
	- since AssetHandles will have a default handle they will also always be valid. so i can change assethandles so that instead of having to ask the asset manager to assign to a handle, I can add a function to asset handle like ChangeAsset() which will take in a path like GetAssetHandleRef (or "default") like it does right now and automatically releases the previous asset and gets a reference to the new asset by its self
- add physics
- make pong
- add a way to export the game into its standalone
- read about vulkan
	- using bindless textures in opengl prevents from using spirv, which prevents from using detailed performance profiling using nsight so i have no choice but to switch now
	- start reading: https://vulkan-tutorial.com/en/Overview
	- another resource: https://paroj.github.io/gltut/
	- another resource: https://vkguide.dev/
	- i need to learn how to:
		- initiailize a vulkan context
		- frame buffer
		- vertex buffer
		- index buffer
		- SSBO
		- Texture2D
		- Shader
		- uniform buffer
		- vertex array
	- or at least these equivalents how they can work into the engine
- change all the vendor library interfaces to rely on command line variables rather than like just builtin.os.tag like it is right now
	- like add a "RenderContext" flag that u can set to either opengl or vulkan or whatever
	- one for audio
	- one for ECS
	- platform utils (like native file dialog)
	- window maker (like glfw)
- make animation system
- add entity picking in the editor
- move away from "managed" structs. aka ones that keep reference to their own allocator, in favor of unmanaged and just passing around allocators more explicitly.
- i need to add components at some point:
	- attribute component (multi)
	- collider component (unique) (for this need to spawn child entity so that it has its own transform)
	- rigid body component (unique)
	- particle component (dont know yet its so far away)
- make event manager clear and free / clear retaining capacity an option in the editor. give it some default of like 10 or something but then make it 
- maybe in the future i can introduce like saved editor states where you can like hotkey or save specific scene setups so you can use later that way you can hot swap like if you want to start a game from the main menu screen after working on some other scene you can quick load the main menu setup and play from there and when it ends you can quick load back to the setup that ur editing currently
- add a function to scene_layer to "spawn player" which is an entity which has a component like PlayerComponent which contains the data related to the player. 
	- then i can for example on scene_layer.OnSceneStart I can spawn a player -> then somehow take control of an entity with a controller component, and then 
	- Then in scene scripts like OnSceneStart you can spawn a player and then set that players "ToControlEntity" to a specified entity
- fix bug where if you minimize it crashes because imgui begin/end children dont match
- does alt + f4 work natively with every program or does it need to be implemented?
- make it so u cant make scenes or anything until you have a project selected first
- Editor settings file
- Add localization for Korean
- add in reinforcement learning to the ECS for sorting components lists
- expose a way to use internal engine assets to the editor
	- like for example if something is white texture and then i change it, i have no way of changing it back to white texture if i change my mind 
	- i can either expose the engine assets OR add some X button that will return the value back to default but I think just exposing engine assets is better and who knows maybe in the future engine assets will contain a whole lots of nice goodies to make dev lives easier
- abstract away the ECS so I can start working on comparing my ECS with others to do research on heuristic functions when dealing with sorting component buckets