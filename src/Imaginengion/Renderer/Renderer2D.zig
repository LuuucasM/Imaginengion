const std = @import("std");
const SSBO = @import("../SSBOs/SSBO.zig");
const VertexArray = @import("../VertexArrays/VertexArray.zig");
const VertexBuffer = @import("../VertexBuffers/VertexBuffer.zig");
const UniformBuffer = @import("../UniformBuffers/UniformBuffer.zig");
const ShaderAsset = @import("../Assets/Assets.zig").ShaderAsset;
const AssetHandle = @import("../Assets/AssetHandle.zig");
const AssetManager = @import("../Assets/AssetManager.zig");
const IndexBuffer = @import("../IndexBuffers/IndexBuffer.zig");

const Assets = @import("../Assets/Assets.zig");
const Texture2D = Assets.Texture2D;

const LinAlg = @import("../Math/LinAlg.zig");
const Vec2f32 = LinAlg.Vec2f32;
const Vec3f32 = LinAlg.Vec3f32;
const Vec4f32 = LinAlg.Vec4f32;
const Quatf32 = LinAlg.Quatf32;
const Mat4f32 = LinAlg.Mat4f32;

const EntityComponents = @import("../GameObjects/Components.zig");
const EntityTransformComponent = EntityComponents.TransformComponent;
const QuadComponent = EntityComponents.QuadComponent;

const Tracy = @import("../Core/Tracy.zig");

const Renderer2D = @This();

const MAX_PATH_LEN = 256;

pub const QuadVertexPositions = Mat4f32{
    Vec4f32{ -0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, 0.5, 0.0, 1.0 },
    Vec4f32{ -0.5, 0.5, 0.0, 1.0 },
};

pub const QuadData = extern struct {
    // std430 layout requires each vec3 to be aligned to 16-bytes. Insert explicit padding so that
    // the offsets generated by Zig match the GLSL struct used in the shader (see SDFShader.glsl).

    // Position : offset 0 – 12
    Position: [3]f32,
    _padding0: f32 = 0.0, // offset 12 – 16 (align vec4 boundary)

    // Rotation : offset 16 – 32
    Rotation: [4]f32,

    // Scale    : offset 32 – 44
    Scale: [3]f32,
    _padding1: f32 = 0.0, // offset 44 – 48

    // Color    : offset 48 – 64
    Color: [4]f32,

    // TexCoords: offset 64 – 72 & 72 – 80 (vec2 have 8-byte alignment)
    TexCoordTop: [2]f32,
    TexCoordBottom: [2]f32,

    // TilingFactor : offset 80 – 84
    TilingFactor: f32,
    _padding2: f32 = 0.0, // offset 84 – 88 (align 64-bit value)

    // TexIndex (uint64) : offset 88 – 96
    TexIndex: u64,
    // Struct size : 96 bytes (multiple of 16)
};

const RectVertexPositions = Mat4f32{
    Vec4f32{ -0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, 0.5, 0.0, 1.0 },
    Vec4f32{ -0.5, 0.5, 0.0, 1.0 },
};

mAllocator: std.mem.Allocator,

mQuadBuffer: SSBO,
mQuadBufferBase: std.ArrayList(QuadData) = .{},
mQuadCountUB: UniformBuffer,

_Allocator: std.mem.Allocator,

pub fn Init(allocator: std.mem.Allocator) !Renderer2D {
    return Renderer2D{
        .mAllocator = allocator,
        .mQuadBuffer = SSBO.Init(@sizeOf(QuadData) * 100),
        .mQuadBufferBase = try std.ArrayList(QuadData).initCapacity(allocator, 100),
        .mQuadCountUB = UniformBuffer.Init(@sizeOf(c_uint)),

        ._Allocator = allocator,
    };
}

pub fn Deinit(self: *Renderer2D) !void {
    self.mQuadBuffer.Deinit();
    self.mQuadBufferBase.deinit(self._Allocator);
    self.mQuadCountUB.Deinit();
}

pub fn StartBatch(self: *Renderer2D) void {
    self.mQuadBufferBase.clearAndFree(self._Allocator);
}

pub fn SetBuffers(self: *Renderer2D) !void {
    const zone = Tracy.ZoneInit("R2D SetBuffers", @src());
    defer zone.Deinit();
    //quads
    if (self.mQuadBufferBase.items.len > 0) {
        self.mQuadBuffer.SetData(self.mQuadBufferBase.items.ptr, self.mQuadBufferBase.items.len * @sizeOf(QuadData), 0);
    }
    var quad_count: c_int = @intCast(self.mQuadBufferBase.items.len);
    self.mQuadCountUB.SetData(@ptrCast(&quad_count), @sizeOf(c_uint), 0);

    //other shapes in the future
}

pub fn BindBuffers(self: *Renderer2D) void {
    const zone = Tracy.ZoneInit("R2D BindBuffers", @src());
    defer zone.Deinit();

    //start at 2 cuz 0 is camera and 1 is rendering mode
    self.mQuadBuffer.Bind(2);
    self.mQuadCountUB.Bind(3);
}

pub fn DrawQuad(self: *Renderer2D, transform_component: *EntityTransformComponent, quad_component: *QuadComponent) !void {
    const zone = Tracy.ZoneInit("R2D DrawQuad", @src());
    defer zone.Deinit();

    const texture_asset = try quad_component.mTexture.GetAsset(Texture2D);

    try self.mQuadBufferBase.append(self._Allocator, .{
        .Position = [3]f32{ transform_component.Translation[0], transform_component.Translation[1], transform_component.Translation[2] },
        .Rotation = [4]f32{ transform_component.Rotation[0], transform_component.Rotation[1], transform_component.Rotation[2], transform_component.Rotation[3] },
        .Scale = [3]f32{ transform_component.Scale[0], transform_component.Scale[1], transform_component.Scale[2] },
        .Color = [4]f32{ quad_component.mColor[0], quad_component.mColor[1], quad_component.mColor[2], quad_component.mColor[3] },
        .TexCoordTop = [2]f32{ quad_component.mTexCoords[0][0], quad_component.mTexCoords[0][1] },
        .TexCoordBottom = [2]f32{ quad_component.mTexCoords[1][0], quad_component.mTexCoords[1][1] },
        .TilingFactor = quad_component.mTilingFactor,
        .TexIndex = texture_asset.GetBindlessID(),
    });
}
