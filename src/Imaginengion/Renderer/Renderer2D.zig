const std = @import("std");
const SSBO = @import("../SSBOs/SSBO.zig");
const VertexArray = @import("../VertexArrays/VertexArray.zig");
const VertexBuffer = @import("../VertexBuffers/VertexBuffer.zig");
const UniformBuffer = @import("../UniformBuffers/UniformBuffer.zig");
const ShaderAsset = @import("../Assets/Assets.zig").ShaderAsset;
const AssetHandle = @import("../Assets/AssetHandle.zig");
const AssetManager = @import("../Assets/AssetManager.zig");
const IndexBuffer = @import("../IndexBuffers/IndexBuffer.zig");

const Assets = @import("../Assets/Assets.zig");
const Texture2D = Assets.Texture2D;

const LinAlg = @import("../Math/LinAlg.zig");
const Vec2f32 = LinAlg.Vec2f32;
const Vec3f32 = LinAlg.Vec3f32;
const Vec4f32 = LinAlg.Vec4f32;
const Quatf32 = LinAlg.Quatf32;
const Mat4f32 = LinAlg.Mat4f32;

const EntityComponents = @import("../GameObjects/Components.zig");
const EntityTransformComponent = EntityComponents.TransformComponent;
const QuadComponent = EntityComponents.QuadComponent;

const Tracy = @import("../Core/Tracy.zig");

const Renderer2D = @This();

const MAX_PATH_LEN = 256;

pub const QuadVertexPositions = Mat4f32{
    Vec4f32{ -0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, 0.5, 0.0, 1.0 },
    Vec4f32{ -0.5, 0.5, 0.0, 1.0 },
};

pub const QuadData = extern struct {
    // std430 layout requires each vec3 to be aligned to 16-bytes. Insert explicit padding so that
    // the offsets generated by Zig match the GLSL struct used in the shader (see SDFShader.glsl).

    // Position : offset 0 – 12
    Position: [3]f32,
    _padding0: f32 = 0.0, // offset 12 – 16 (align vec4 boundary)

    // Rotation : offset 16 – 32
    Rotation: [4]f32,

    // Scale    : offset 32 – 44
    Scale: [3]f32,
    _padding1: f32 = 0.0, // offset 44 – 48

    // Color    : offset 48 – 64
    Color: [4]f32,

    // TexCoords: offset 64 – 72 & 72 – 80 (vec2 have 8-byte alignment)
    TexCoordTop: [2]f32,
    TexCoordBottom: [2]f32,

    // TilingFactor : offset 80 – 84
    TilingFactor: f32,
    _padding2: f32 = 0.0, // offset 84 – 88 (align 64-bit value)

    // TexIndex (uint64) : offset 88 – 96
    TexIndex: u64,
    // Struct size : 96 bytes (multiple of 16)
};

//pub const CircleData = extern struct {
//    Position: [3]f32,
//    Normal: [3]f32,
//    Radius: f32,
//    Color: [4]f32,
//};

//pub const LineData = extern struct {
//    P1: [3]f32,
//    P2: [3]f32,
//    Normal: [3]f32,
//    Thickness: f32,
//    Color: [4]f32,
//};

const RectVertexPositions = Mat4f32{
    Vec4f32{ -0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, -0.5, 0.0, 1.0 },
    Vec4f32{ 0.5, 0.5, 0.0, 1.0 },
    Vec4f32{ -0.5, 0.5, 0.0, 1.0 },
};

mAllocator: std.mem.Allocator,

mQuadBuffer: SSBO,
mQuadBufferBase: std.ArrayList(QuadData),
mQuadCountUB: UniformBuffer,

//mCircleBuffer: SSBO,
//mCircleBufferBase: std.ArrayList(CircleData),

//mLineBuffer: SSBO,
//mLineBufferBase: std.ArrayList(LineData),

pub fn Init(allocator: std.mem.Allocator) !Renderer2D {
    return Renderer2D{
        .mAllocator = allocator,
        .mQuadBuffer = SSBO.Init(@sizeOf(QuadData) * 100),
        .mQuadBufferBase = try std.ArrayList(QuadData).initCapacity(allocator, 100),
        .mQuadCountUB = UniformBuffer.Init(@sizeOf(c_uint)),
        //.mCircleBuffer = SSBO.Init(@sizeOf(CircleData) * 100),
        //.mCircleBufferBase = try std.ArrayList(CircleData).initCapacity(allocator, 100),
        //.mLineBuffer = SSBO.Init(@sizeOf(LineData) * 100),
        //.mLineBufferBase = try std.ArrayList(LineData).initCapacity(allocator, 100),
    };
}

pub fn Deinit(self: *Renderer2D) !void {
    self.mQuadBuffer.Deinit();
    self.mQuadBufferBase.deinit();
    self.mQuadCountUB.Deinit();
    //self.mCircleBuffer.Deinit();
    //self.mCircleBufferBase.deinit();
    //self.mLineBuffer.Deinit();
    //self.mLineBufferBase.deinit();
}

pub fn StartBatch(self: *Renderer2D) void {
    self.mQuadBufferBase.clearAndFree();
}

pub fn SetBuffers(self: *Renderer2D) !void {
    const zone = Tracy.ZoneInit("R2D SetBuffers", @src());
    defer zone.Deinit();
    //quads
    if (self.mQuadBufferBase.items.len > 0) {
        self.mQuadBuffer.SetData(self.mQuadBufferBase.items.ptr, self.mQuadBufferBase.items.len * @sizeOf(QuadData), 0);
    }
    var quad_count: c_int = @intCast(self.mQuadBufferBase.items.len);
    self.mQuadCountUB.SetData(@ptrCast(&quad_count), @sizeOf(c_uint), 0);

    //other shapes in the future
}

pub fn BindBuffers(self: *Renderer2D) void {
    const zone = Tracy.ZoneInit("R2D BindBuffers", @src());
    defer zone.Deinit();
    self.mQuadBuffer.Bind(2); //start at 2 cuz 0 is camera and 1 is resolution
    self.mQuadCountUB.Bind(3);
}

pub fn DrawQuad(self: *Renderer2D, transform_component: *EntityTransformComponent, quad_component: *QuadComponent) !void {
    const zone = Tracy.ZoneInit("R2D DrawQuad", @src());
    defer zone.Deinit();

    const texture_asset = try quad_component.mTexture.GetAsset(Texture2D);

    try self.mQuadBufferBase.append(.{
        .Position = [3]f32{ transform_component.Translation[0], transform_component.Translation[1], transform_component.Translation[2] },
        .Rotation = [4]f32{ transform_component.Rotation[0], transform_component.Rotation[1], transform_component.Rotation[2], transform_component.Rotation[3] },
        .Scale = [3]f32{ transform_component.Scale[0], transform_component.Scale[1], transform_component.Scale[2] },
        .Color = [4]f32{ quad_component.mColor[0], quad_component.mColor[1], quad_component.mColor[2], quad_component.mColor[3] },
        .TexCoordTop = [2]f32{ quad_component.mTexCoords[0][0], quad_component.mTexCoords[0][1] },
        .TexCoordBottom = [2]f32{ quad_component.mTexCoords[1][0], quad_component.mTexCoords[1][1] },
        .TilingFactor = quad_component.mTilingFactor,
        .TexIndex = texture_asset.GetBindlessID(),
    });
}

//pub fn DrawCircle(self: *Renderer2D, position: Vec3f32, rotation: Quatf32, radius: f32, color: Vec4f32) !void {
//    try self.mCircleBufferBase.append(.{
//        .Position = position,
//        .Normal = LinAlg.NormalFromQuat(rotation),
//        .Radius = radius,
//        .Color = [4]f32{ color[0], color[1], color[2], color[3] },
//    });
//}
//
////TODO: FINISH DRAWING LINE
//pub fn DrawLine(self: *Renderer2D, p1: Vec3f32, p2: Vec3f32, rotation: Quatf32, thickness: f32, color: Vec4f32) !void {
//    const rot_norm = LinAlg.NormalFromQuat(rotation);
//    const axis = LinAlg.NormalizeVec3(p1 - p2);
//
//    try self.mLineBufferBase.append(.{
//        .P1 = p1,
//        .P2 = p2,
//        .Normal = LinAlg.NormalizeVec3(rot_norm - @as(Vec3f32, @splat(LinAlg.Vec3DotVec3(rot_norm, axis))) * axis),
//        .Thickness = thickness,
//        .Color = color,
//    });
//}
